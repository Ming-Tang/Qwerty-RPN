<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>QwertyRPN.pm</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#assembler_to_rpn">ASSEMBLER to RPN</a></li>
		<li><a href="#quick_reference">QUICK REFERENCE</a></li>
	</ul>

	<li><a href="#examples">EXAMPLES</a></li>
	<li><a href="#todo">TODO</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
 use Math::QwertyRPN qw(eval_rpn);
 print eval_rpn &quot;12 54 + 12 *&quot;; # 792</pre>
<p>A Reverse Polish notation calculator that has most opcodes of stack-based
assembly languages. It is generally Turing-complete (needs to be tested).</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>The <code>eval_rpn</code> function evaluates an expression. The first argument is a string
containing the expression. The function returns the stack after the evaluation.
When an error occurred, <code>die</code> will be called. However, you can trap errors
by using <code>eval</code>, <code>do</code> or other try-catch modules.</p>
<p>An RPN expression contain a sequence of operations, they need to be
seperated by whitespaces or line breaks in some places,
to know more about Reverse Polish notation, read the article on
Wikipedia: <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">http://en.wikipedia.org/wiki/Reverse_Polish_notation</a>.</p>
<p>To add a line comment, use <code>;</code>. For example: <code>1 1 + ; push 1 twice, and add them</code></p>
<p>The operators that do not exist in other RPN calculators include GOTO labels,
I/O and comparsion operators. To create a GOTO label, write <code>&gt;label_name</code>,
where <code>label_name</code> is the name of the label.</p>
<p>The GOTO statement is like <code>&gt;label_name</code>. However, GOTO is conditional,
it is only made if the value on the top of stack is not 0 (zero). Also,
GOTO has a side effect of popping the stack.</p>
<p><code>12 3 &lt;label</code> will end up with 12 (instead of 12 3) on the stack.</p>
<p>Variables can be created and read by using the <code>=</code> and <code>$</code> operator.
To get a variable, write <code>$name</code>, where <code>name</code> is the
name of the variable. The value of that variable will be pushed
to the top of the stack.
To set a variable, write <code>=name</code>. The stack will be popped.</p>
<p>For example, <code>50 =value</code> will set variable <code>value</code> to 50. The stack
will end up empty because the 50 was popped to assign the variable.</p>
<p>You can read-write variables in the based on the value on the top of the stack
by using variable-variables. To read a variable-variable, use <code>$$</code>.
The expression <code>50 $$</code> pushes the value of variable <code>50</code> to the stack.
The top of the stack will be popped
and it becomes the name of the variable-variable.</p>
<p>To write a variable-variable, write <code>=$</code>. The top of the stack will be popped
and it becomes the name of the variable-variable.</p>
<p>The following expression outputs 10:</p>
<pre>
 10 ; stack:10
 5  ; stack:10 5
 =$ ;            variables:$5=10
 5  ; stack:5    variables:$5=10
 $$ ; stack:10   variables:$5=10</pre>
<p>Arrays can be made by using variable-variables.
Variable-variables are made to make this language closer to Turing-complete.</p>
<p>
</p>
<h2><a name="assembler_to_rpn">ASSEMBLER to RPN</a></h2>
<p>A typical stack-based assembly code looks like this:</p>
<pre>
 push 180  ; stack is 180
 push 250  ; stack is 180 250
 add       ; stack is 430
 push 50   ; stack is 430 50
 jeq LABEL ; jump if equals</pre>
<p>It will be translated to RPN like this:</p>
<pre>
 180 250 + 50 = &lt;LABEL</pre>
<p>The PUSH opcode will be converted to numbers, and ADD will be converted
to <code>+</code> as expected. However, there is no JEQ, JLT, JGT and other
compare-and-goto opcodes in RPN, so you must compare manually and goto.
<code>50 = </code> means to compare the top of the stack with 50, and pushes 0 or 1
based on the result of the comparsion.</p>
<p>
</p>
<h2><a name="quick_reference">QUICK REFERENCE</a></h2>
<p>Here is a list of all operators by order of QWERTY keyboard.
I don't have time to document all of them, so I used assembler opcode names.</p>
<pre>
 +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+
 | ~ not  | ! pop  | @ getn | # putn | $ swap | % mod  | ^ pow  | &amp; and  | * mul  | ( dec  | ) inc  | _ neg  | + add  |
 | ` xor  | 1 ---- | 2 ---- | 3 ---- | 4 ---- | 5 ---- | 6 ---- | 7 ---- | 8 ---- | 9 ---- | 0 ---- | - sub  | = eq   |
 +--------+--------+--------+--------+--------+--------+--------+--------+-----------------+--------+--------+--------+
 | Q      | W      | E 10^x | R root | T atan | Y      | U      | I      | O      | P      | { shl  | } shr  | | or   |
 | q x^2  | w      | e exp  | r sqrt | t tan  | y      | u      | i 1/x  | o      | p pi   | [ flr  | ] ceil | \ roun |
 +--------+--------+--------+--------+--------+--------+--------+--------+-----------------+--------+--------+--------+
 | A avg  | S asin | D rad  | F      | G      | H      | J      | K      | L log  | : dup  | &quot; ge   |########|########|
 | a abs  | s sin  | d deg  | f fac  | g      | h      | j      | k      | l ln   | ;      | ' le   |########|########|
 +--------+--------+--------+--------+--------+--------+--------+--------+-----------------+--------+--------+--------+
 | Z      | X die  | C acos | V      | B      | N      | M max  | &lt; lt   | &gt; gt   | ? rand |########|########|########|
 | z      | x exit | c cos  | v      | b bool | n neg  | m min  | , getc | . putc | / div  |########|########|########|
 +--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+</pre>
<p>Here is the list of other operations.</p>
<ol>
<li>
<p><em>NUMBER</em>: Pushes a number to the stack.</p>
</li>
<li>
<p><code>&lt;</code>: Jumps to a label if the value on the top of the stack is not 0 (zero).
Example <code>&lt;loop</code></p>
</li>
<li>
<p><code>&gt;</code>: Creates a label. Example: <code>&gt;loop</code></p>
</li>
<li>
<p><code>$</code><em>NAME</em>: Gets a variable. <code>$var1</code> will push the value of <code>var1</code>
on the top of the stack.</p>
</li>
<li>
<p><code>=</code><em>NAME</em>: Sets a variable. <code>12 =var1</code> will set <code>var1</code> to 12, because
the item on the top of the stack is 12. Then 12 on the top of the stack will
be popped.</p>
</li>
<li>
<p><code>$</code><em>NAME</em>: Gets a variable-variable.</p>
</li>
<li>
<p><code>=$</code>Sets a variable-variable.</p>
</li>
</ol>
<p>
</p>
<hr />
<h1><a name="examples">EXAMPLES</a></h1>
<p>Ask user to input 2 numbers, and print their sum.</p>
<pre>
 @@+#</pre>
<p>Digital root calculator</p>
<pre>
 1@1-+9%</pre>
<p>Locals-based factorial</p>
<pre>
 ;  CODE                ; PSEUDOCODE              
 @ =value               ; value = input_number();
 1 =result              ; result = 1;
 $value =i              ; i = value;
 &gt;loop                  ; loop:
  $result $i * =result  ;  result *= i;
  $i ( =i $i            ;  i --;
 &lt;loop                  ; if ($i) { goto loop; } 
 $result                ; return result;</pre>
<p>without comments:</p>
<pre>
 @ =value 1 =result $value =i &gt;loop $result $i * =result $i ( =i $i &lt;loop $result</pre>
<p>Countdown from 15</p>
<pre>
 16&gt;loop(::#32.&lt;loop!</pre>
<p>
</p>
<hr />
<h1><a name="todo">TODO</a></h1>
<ol>
<li>
<p>Stack-based factorial example</p>
</li>
<li>
<p>Support of subroutines/functions</p>
</li>
<li>
<p>More detailed documentation</p>
</li>
</ol>

</body>

</html>
